# Testing Guide for On-Chain Implementation

This guide walks you through testing the full on-chain functionality.

## Prerequisites

### 1. Install Solana CLI

```bash
# On macOS/Linux
sh -c "$(curl -sSfL https://release.solana.com/stable/install)"

# On Windows (PowerShell)
cmd /c "curl https://release.solana.com/stable/install -o install-solana.bat && install-solana.bat"
```

Verify installation:
```bash
solana --version
```

### 2. Install Anchor Framework

```bash
# macOS/Linux
cargo install --git https://github.com/coral-xyz/anchor avm --locked --force
avm install latest
avm use latest

# Windows
# Use WSL or install via cargo
```

### 3. Setup Solana Wallet

```bash
# Create a new wallet (or use existing)
solana-keygen new

# Set to devnet
solana config set --url devnet

# Airdrop SOL for testing
solana airdrop 2

# Check balance
solana balance
```

### 4. Install Node.js Dependencies

```bash
cd backend
npm install

# If you need @coral-xyz/anchor for client-side testing
npm install @coral-xyz/anchor
```

## Step 1: Deploy the Solana Program

### 1.1 Build the Program

```bash
cd programs/tap_to_pay
anchor build
```

This will:
- Compile the Rust program
- Generate the IDL (Interface Definition Language)
- Create the program binary

### 1.2 Deploy to Devnet

```bash
# Make sure you have SOL in your wallet
solana balance

# Deploy the program
anchor deploy

# Note the Program ID from the output
# Example: Program Id: YourProgramId1111111111111111111111111
```

### 1.3 Update Environment Variables

Update `backend/.env`:
```env
SOLANA_RPC_URL=https://api.devnet.solana.com
PROGRAM_ID=YourDeployedProgramIdHere
```

Update `programs/tap_to_pay/src/lib.rs`:
```rust
declare_id!("YourDeployedProgramIdHere");
```

Rebuild after updating:
```bash
anchor build
anchor deploy
```

## Step 2: Start the Backend

```bash
cd backend
npm start
```

The backend should start on `http://localhost:3001`

## Step 3: Test Payment Intent Creation

### 3.1 Create a Payment Intent via API

```bash
curl -X POST http://localhost:3001/payment_intents \
  -H "Content-Type: application/json" \
  -d '{
    "amount": 10.00,
    "merchant_id": "4UznnYY4AMzAmss6AqeAvqUs5KeWYNinzKE2uFFQZ16U",
    "currency": "USDC",
    "tip_amount": 1.00,
    "chain": "Solana"
  }'
```

**Response should include:**
```json
{
  "id": "uuid-here",
  "amount": 10,
  "pda": "PDA_ADDRESS_HERE",
  "bump": 255,
  ...
}
```

**Save the `id` and `pda` for next steps!**

### 3.2 Check Status (Should show off-chain initially)

```bash
curl http://localhost:3001/payment_intents/{PAYMENT_INTENT_ID}/status
```

Response:
```json
{
  "id": "...",
  "status": "pending",
  "on_chain": false,
  "pda": "PDA_ADDRESS",
  ...
}
```

## Step 4: Create PaymentIntent Account On-Chain

### Option A: Using Anchor Client (Recommended)

Create a test script `backend/test-create-account.js`:

```javascript
import { Program, AnchorProvider, Wallet } from '@coral-xyz/anchor';
import { Connection, Keypair, PublicKey, SystemProgram } from '@solana/web3.js';
import { readFileSync } from 'fs';
import dotenv from 'dotenv';

dotenv.config();

// Load IDL (generated by anchor build)
const idl = JSON.parse(readFileSync('../target/idl/tap_to_pay.json', 'utf8'));
const programId = new PublicKey(process.env.PROGRAM_ID);
const connection = new Connection(process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com', 'confirmed');

// Load merchant keypair (your Solana wallet)
const keypairPath = process.env.MERCHANT_KEYPAIR_PATH || '~/.config/solana/id.json';
const keypairData = JSON.parse(readFileSync(keypairPath, 'utf8'));
const merchantKeypair = Keypair.fromSecretKey(Uint8Array.from(keypairData));

const wallet = new Wallet(merchantKeypair);
const provider = new AnchorProvider(connection, wallet, {});
const program = new Program(idl, programId, provider);

async function createPaymentIntentAccount(paymentIntentId, amount, nonceHex) {
  try {
    // Derive PDA
    const [pda, bump] = PublicKey.findProgramAddressSync(
      [
        Buffer.from('payment_intent'),
        Buffer.from(paymentIntentId, 'utf8')
      ],
      programId
    );

    console.log(`Creating PaymentIntent account:`);
    console.log(`  ID: ${paymentIntentId}`);
    console.log(`  PDA: ${pda.toBase58()}`);
    console.log(`  Amount: ${amount}`);
    console.log(`  Merchant: ${merchantKeypair.publicKey.toBase58()}`);

    // Convert nonce from hex string to [u8; 32]
    const nonce = Buffer.from(nonceHex, 'hex');
    if (nonce.length !== 32) {
      throw new Error('Nonce must be 32 bytes (64 hex characters)');
    }
    const nonceArray = Array.from(nonce);

    // Call create_payment_intent instruction
    const tx = await program.methods
      .createPaymentIntent(paymentIntentId, new anchor.BN(amount), nonceArray)
      .accounts({
        paymentIntent: pda,
        merchant: merchantKeypair.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log(`✓ Transaction signature: ${tx}`);
    console.log(`✓ Account created at: ${pda.toBase58()}`);

    return { tx, pda: pda.toBase58() };
  } catch (error) {
    console.error('Error creating account:', error);
    throw error;
  }
}

// Run if called directly
const paymentIntentId = process.argv[2];
const amount = parseInt(process.argv[3] || '10000000'); // Amount in smallest units
const nonce = process.argv[4]; // 64-character hex string

if (!paymentIntentId || !nonce) {
  console.error('Usage: node test-create-account.js <payment_intent_id> <amount> <nonce_hex>');
  console.error('Example: node test-create-account.js uuid-123 10000000 a1b2c3...');
  process.exit(1);
}

createPaymentIntentAccount(paymentIntentId, amount, nonce);
```

**Run it:**
```bash
cd backend
node test-create-account.js {PAYMENT_INTENT_ID} 10000000 {NONCE_FROM_RESPONSE}
```

### Option B: Using Solana CLI (Manual)

You'll need to build the transaction manually. This is more complex - Option A is recommended.

## Step 5: Verify On-Chain Account Exists

### 5.1 Check Status Endpoint

```bash
curl http://localhost:3001/payment_intents/{PAYMENT_INTENT_ID}/status
```

**Should now show:**
```json
{
  "id": "...",
  "status": "pending",
  "on_chain": true,
  "pda": "PDA_ADDRESS",
  ...
}
```

### 5.2 Check Account on Solana Explorer

Visit: `https://explorer.solana.com/address/{PDA_ADDRESS}?cluster=devnet`

You should see the account with data.

### 5.3 Query Account Directly

```bash
solana account {PDA_ADDRESS}
```

## Step 6: Test Payment Processing

### 6.1 Build Pay Invoice Transaction

Create `backend/test-pay-invoice.js`:

```javascript
import { Program, AnchorProvider, Wallet } from '@coral-xyz/anchor';
import { Connection, Keypair, PublicKey, SystemProgram } from '@solana/web3.js';
import { readFileSync } from 'fs';
import dotenv from 'dotenv';

dotenv.config();

const idl = JSON.parse(readFileSync('../target/idl/tap_to_pay.json', 'utf8'));
const programId = new PublicKey(process.env.PROGRAM_ID);
const connection = new Connection(process.env.SOLANA_RPC_URL || 'https://api.devnet.solana.com', 'confirmed');

// Load payer keypair (customer wallet)
const payerKeypairPath = process.env.PAYER_KEYPAIR_PATH || '~/.config/solana/id.json';
const payerKeypairData = JSON.parse(readFileSync(payerKeypairPath, 'utf8'));
const payerKeypair = Keypair.fromSecretKey(Uint8Array.from(payerKeypairData));

const wallet = new Wallet(payerKeypair);
const provider = new AnchorProvider(connection, wallet, {});
const program = new Program(idl, programId, provider);

async function payInvoice(paymentIntentId, amount, nonceHex) {
  try {
    const [pda, bump] = PublicKey.findProgramAddressSync(
      [
        Buffer.from('payment_intent'),
        Buffer.from(paymentIntentId, 'utf8')
      ],
      programId
    );

    const nonce = Buffer.from(nonceHex, 'hex');
    const nonceArray = Array.from(nonce);

    console.log(`Paying invoice:`);
    console.log(`  Payment Intent ID: ${paymentIntentId}`);
    console.log(`  PDA: ${pda.toBase58()}`);
    console.log(`  Amount: ${amount}`);
    console.log(`  Payer: ${payerKeypair.publicKey.toBase58()}`);

    const tx = await program.methods
      .payInvoice(paymentIntentId, new anchor.BN(amount), nonceArray, bump)
      .accounts({
        paymentIntent: pda,
        payer: payerKeypair.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log(`✓ Payment transaction: ${tx}`);
    console.log(`✓ Check status endpoint to verify payment was processed`);

    return tx;
  } catch (error) {
    console.error('Error paying invoice:', error);
    throw error;
  }
}

const paymentIntentId = process.argv[2];
const amount = parseInt(process.argv[3] || '10000000');
const nonce = process.argv[4];

if (!paymentIntentId || !nonce) {
  console.error('Usage: node test-pay-invoice.js <payment_intent_id> <amount> <nonce_hex>');
  process.exit(1);
}

payInvoice(paymentIntentId, amount, nonce);
```

**Run it:**
```bash
node test-pay-invoice.js {PAYMENT_INTENT_ID} 10000000 {NONCE}
```

### 6.2 Verify Payment Confirmed

**Check backend logs** - you should see:
```
Payment update for {id}: { status: 'paid', ... }
✓ Payment confirmed on-chain: {id}
```

**Check status endpoint:**
```bash
curl http://localhost:3001/payment_intents/{PAYMENT_INTENT_ID}/status
```

**Should show:**
```json
{
  "status": "paid",
  "tx_signature": "PAYER_PUBKEY",
  "on_chain": true,
  ...
}
```

## Step 7: Test Real-Time Monitoring

### 7.1 Watch Backend Logs

Keep the backend running and watch for:
```
Watching PaymentIntent PDA: {PDA} for payment intent: {ID}
```

### 7.2 Trigger Payment

Run the pay invoice script from Step 6.

### 7.3 Verify Automatic Update

The backend should automatically:
1. Detect account change via WebSocket
2. Decode updated account data
3. Update database with `status = "paid"`
4. Log confirmation

## Step 8: Integration Testing

### 8.1 Full Flow Test

1. **Create payment intent** → Get PDA
2. **Create on-chain account** → Verify `on_chain: true`
3. **Process payment** → Verify status updates automatically
4. **Check database** → Verify database was updated
5. **Check status endpoint** → Verify returns on-chain status

### 8.2 Test Error Cases

- **Invalid amount**: Try paying with wrong amount
- **Invalid nonce**: Try paying with wrong nonce
- **Double payment**: Try paying same invoice twice
- **Non-existent account**: Check status of account that doesn't exist on-chain

## Quick Test Script

Create `backend/quick-test.sh`:

```bash
#!/bin/bash

# 1. Create payment intent
echo "Creating payment intent..."
RESPONSE=$(curl -s -X POST http://localhost:3001/payment_intents \
  -H "Content-Type: application/json" \
  -d '{
    "amount": 10.00,
    "merchant_id": "4UznnYY4AMzAmss6AqeAvqUs5KeWYNinzKE2uFFQZ16U",
    "currency": "USDC"
  }')

PAYMENT_ID=$(echo $RESPONSE | jq -r '.id')
NONCE=$(echo $RESPONSE | jq -r '.nonce')
PDA=$(echo $RESPONSE | jq -r '.pda')

echo "Payment Intent ID: $PAYMENT_ID"
echo "PDA: $PDA"
echo "Nonce: $NONCE"

# 2. Check initial status
echo -e "\nChecking initial status..."
curl -s http://localhost:3001/payment_intents/$PAYMENT_ID/status | jq

# 3. Create on-chain account (requires wallet)
echo -e "\nTo create on-chain account, run:"
echo "node test-create-account.js $PAYMENT_ID 10000000 $NONCE"

# 4. After creating account, check status again
echo -e "\nAfter creating account, check status:"
echo "curl http://localhost:3001/payment_intents/$PAYMENT_ID/status | jq"
```

## Troubleshooting

### Account Not Found
- Verify program is deployed
- Check PROGRAM_ID matches deployed program
- Verify PDA derivation is correct

### Transaction Fails
- Check wallet has enough SOL
- Verify account exists before calling pay_invoice
- Check amount and nonce match exactly

### Backend Not Detecting Changes
- Verify WebSocket connection to Solana RPC
- Check backend logs for errors
- Verify account actually changed on-chain

### Decoding Errors
- Verify account data structure matches program
- Check discriminator (first 8 bytes)
- Ensure account is from correct program

## Next Steps

1. **Deploy to Mainnet**: Update RPC URL and program ID
2. **Add Frontend Integration**: Create accounts from frontend
3. **Add Error Handling**: Better error messages and retries
4. **Add Monitoring**: Metrics and alerts for failed transactions
5. **Add Indexing**: Faster historical queries via event indexing

